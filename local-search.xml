<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用python脚本下载 youtube 视频</title>
    <link href="/2023/02/11/%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BD-youtube-%E8%A7%86%E9%A2%91/"/>
    <url>/2023/02/11/%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BD-youtube-%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">尝试了很多次群晖的下载youtube视频的docker，无奈各种原因总是配置不成功。只能自己在docker里面搭建 python 和ffmpeg环境。</code></pre><p>Ubuntu 22.04 里面已经安装 python3 了，不过pip3没有安装，需要手动安装。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install python3-pip<br></code></pre></td></tr></table></figure><p>tips: 给docker共享文件夹：</p><img src="/2023/02/11/%E4%BD%BF%E7%94%A8python%E8%84%9A%E6%9C%AC%E4%B8%8B%E8%BD%BD-youtube-%E8%A7%86%E9%A2%91/001.jpg" class="" title="docker存储空间设置"><p>拷贝过去文件 ytube.py :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> pytube <span class="hljs-keyword">import</span> YouTube<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> re<br><span class="hljs-comment">#from pywebio.input import *</span><br><br>temp_video = <span class="hljs-string">&quot;&quot;</span><br>temp_audio = <span class="hljs-string">&quot;&quot;</span><br>base_dir = <span class="hljs-string">&#x27;/home/share&#x27;</span><br><br>proxy_handler = &#123;<br><span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;http://192.168.50.35:7890&quot;</span>,<br><span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;http://192.168.50.35:7890&quot;</span>,<br><span class="hljs-string">&quot;socks5&quot;</span>:<span class="hljs-string">&quot;socks5://192.168.50.35:7891&quot;</span><br>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">onComplete</span>(<span class="hljs-params">stream, file_path</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;onComplete:   &#x27;</span> + file_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\r&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">onProgress</span>(<span class="hljs-params">stream, chunk, remains</span>):<br>    total = stream.filesize<br>    percent = (total-remains) / total * <span class="hljs-number">100</span><br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;  &#123;:05.2f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(percent)  )<br>    <span class="hljs-comment">#print (&#x27;下載中… &#123;:05.2f&#125;%&#x27;.format(percent), end=&#x27;\r&#x27; )</span><br>    <span class="hljs-keyword">return</span> <br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download_media</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-keyword">try</span>:<br>        yt = YouTube(url, proxies=proxy_handler, on_progress_callback=onProgress,on_complete_callback=onComplete)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下載影片時發生錯誤，請確認網路連線和YouTube網址無誤。&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment">#filter = yt.streams.filter</span><br><br>    <span class="hljs-keyword">global</span> temp_video,temp_audio<br>    temp_video = os.path.join(base_dir, <span class="hljs-string">&#x27;video_out.mp4&#x27;</span>)<br>    temp_audio = os.path.join(base_dir, <span class="hljs-string">&#x27;audio_out.mp4&#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(temp_video)<br>    <span class="hljs-built_in">print</span>(temp_audio)<br>    <br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> count &lt;= <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment">#download audio only</span><br>            yt.streams.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;audio&quot;</span>,abr=<span class="hljs-string">&quot;128kbps&quot;</span>).first().download(filename=temp_audio)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-comment">#download video only</span><br>    video_strem = yt.streams.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;video&quot;</span>, res=<span class="hljs-string">&quot;1080p&quot;</span>).first()<br>    <span class="hljs-keyword">if</span> video_strem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        video_strem = yt.streams.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;video&quot;</span>, res=<span class="hljs-string">&quot;720p&quot;</span>).first()<br>    <span class="hljs-keyword">if</span> video_strem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        video_strem = yt.streams.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;video&quot;</span>, res=<span class="hljs-string">&quot;480p&quot;</span>).first()<br>    count = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> count &lt;= <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">try</span>:<br>            video_strem.download(filename=temp_video)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>:<br>            count += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">continue</span><br><br>    ori_name = yt.title<br>    <span class="hljs-comment">#ori_name = re.sub(r&#x27;[.,&quot;\&#x27;-?:!;]&#x27;, &#x27;&#x27;, ori_name)</span><br>    merge_media(ori_name + <span class="hljs-string">&quot;.mp4&quot;</span>)<br>    os.remove(temp_audio)<br>    os.remove(temp_video)<br><br>    <span class="hljs-comment">## 把音频和视频合并起来成一个文件，如果像下面一样用 ffmpeg 的 python 接口，则导致耗时很长，</span><br>    <span class="hljs-comment">## 长达 ffmpeg命令方式 的几十倍，可能它们的实现方式不一样，这里不深究了。</span><br>    <span class="hljs-comment"># import ffmpeg</span><br>    <span class="hljs-comment"># video = ffmpeg.input(&quot;video.mp4&quot;)</span><br>    <span class="hljs-comment"># audio = ffmpeg.input(&quot;audio.mp4&quot;)</span><br>    <span class="hljs-comment"># ffmpeg.output(audio, video, &quot;finished_video.mp4&quot;).run(overwrite_output=True)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_media</span>(<span class="hljs-params">out_name</span>):<br>    <span class="hljs-keyword">global</span> temp_video,temp_audio<br>    temp_output = os.path.join(base_dir, out_name)<br>    <span class="hljs-built_in">print</span>(temp_output)<br>    cmd = <span class="hljs-string">f&#x27;ffmpeg -i <span class="hljs-subst">&#123;temp_video&#125;</span> -i <span class="hljs-subst">&#123;temp_audio&#125;</span>  -map 0:v -map 1:a   -c copy -y \&#x27;<span class="hljs-subst">&#123;temp_output&#125;</span>\&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        subprocess.run(cmd, shell=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment"># 視訊檔重新命名</span><br>        <span class="hljs-comment">#os.remove(&#x27;./audio_out.mp4&#x27;)</span><br>        <span class="hljs-comment">#os.remove(&#x27;./video_out.mp4&#x27;)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;音视频合并完成&#x27;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;音视频合并失败&#x27;</span>)<br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./src.txt&quot;</span>, mode=<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    lines = file.readlines()<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>        download_media(line)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>创建一个空文件src.txt ,把需要下载的ytube视频链接放在这个txt里面。</p><p>给ubuntu 安装 ffmpeg 以供转码需要，</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install ffmpeg<br></code></pre></td></tr></table></figure><p>  代码说明：<br>1)一般下载工具1080p是没有音频的，720p及以下才有音频，这是由youtube的DASH Streams 特性决定的。这里把1080p视频 和音频合并，所以要比大多数下载工具要好一些。<br>2)对于音频流选择 mp4a.xxx 而不是 opus ，方便后面合并音视频，<br>3)合并音视频 选择 ffmpeg 命令方式而不是用 ffmpeg.input ffmpeg.output方法，那样会用很长时间，cpu占用率也很高，具体原因就不研究了。<br>4)proxy_handler 是代理设置，这里用的是软路由的地址。需要根据自己情况修改。</p><p>参考链接：</p><p><a href="https://swf.com.tw/?p=1402">YouTube影片下載（五）：PyTube3程式庫更新說明</a><br><a href="https://www.jianshu.com/p/e18cdb1053d0">python下载youtube视频</a><br><a href="https://haibei.online/posts/3728898916#github%E5%9C%B0%E5%9D%80">pytube，下载YouTube视频无压力</a></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10小技巧</title>
    <link href="/2023/02/11/win10%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2023/02/11/win10%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs">1) win10下双击打开 ps1脚本文件:</code></pre><p>ps1脚本就如linux下的 sh 脚本一样，不同的是默认的在 win10 下双击是用记事本打开查看，而不是运行的，此时就要修改注册表</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">HKEY_CLASSES_ROOT\Microsoft<span class="hljs-selector-class">.PowerShellScript</span>.<span class="hljs-number">1</span>\Shell\open\command<br></code></pre></td></tr></table></figure><p>原来是这个值是:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;C:\Windows\System32\notepad.exe<span class="hljs-string">&quot; &quot;</span>%<span class="hljs-number">1</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这里要改为:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&quot;C:\Windows\System32\WindowsPowerShell\v1.<span class="hljs-number">0</span>\powershell.exe<span class="hljs-string">&quot; -noLogo -ExecutionPolicy unrestricted -file &quot;</span>%<span class="hljs-number">1</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>改完之后就可以双击 ps1 脚本调用 powershell 了。</p><pre><code class="hljs">2)文件拖拽计算校验和:</code></pre><p>win10下面哈希值的计算命令比起 linux 来要复杂一些，如果每次都要输入命令和路径是一件很麻烦的事，可以用cmd脚本只要把文件拖拽过去就可以实现计算校验和了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@echo</span> off<br>echo 请输入选择:<br>echo <span class="hljs-number">1</span>: MD5<br>echo <span class="hljs-number">2</span>: SHA1<br>echo <span class="hljs-number">3</span>: SHA256<br><br>set /p num=<br><br>echo. <br>echo. <br>echo. <br><br>if <span class="hljs-string">&quot;%num%&quot;</span>==<span class="hljs-string">&quot;1&quot;</span> (<br>certutil -hashfile <span class="hljs-string">&quot;%~n1%~x1&quot;</span> MD5 <br>)<br><br>if <span class="hljs-string">&quot;%num%&quot;</span>==<span class="hljs-string">&quot;2&quot;</span> (<br>certutil -hashfile <span class="hljs-string">&quot;%~n1%~x1&quot;</span> SHA1 <br>)<br><br>if <span class="hljs-string">&quot;%num%&quot;</span>==<span class="hljs-string">&quot;3&quot;</span> (<br>certutil -hashfile <span class="hljs-string">&quot;%~n1%~x1&quot;</span> SHA256 <br>)<br><br>pause<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在群晖上创建ubuntu docker容器并用ssh访问</title>
    <link href="/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/"/>
    <url>/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>   有时候用一个 python 脚本完成某个工作，为了不让这个python的环境影响别的工程，只能给这个python 脚本单独准备一个运行环境，<br>如果是虚拟机环境占用资源比较多，而且群晖cpu功能较弱，无法同时开启很多虚拟机，此时只能选择docker。<br>   首先准备ubuntu 映像，这里选择 dokken&#x2F;ubuntu22.04 </p><img src="/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/001.jpg" class="" title="ubuntu映像"><p>   使用这个映像创建出一个容器，网卡就选择普通的 bridge 就行了。注意映射下 22 端口。</p><img src="/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/002.jpg" class="" title="端口"><p>   刚创建出来的容器还没有安装ssh ，首先安装 ssh-server</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">apt-get install openssh-server<br></code></pre></td></tr></table></figure><p>   详细可以参考文章 <a href="https://blog.csdn.net/jackghq/article/details/54974141">ubuntu开启SSH服务远程登录</a></p><p>   执行 ‘passwd’ 命令，修改 root 密码</p><p>   安装完ssh并且启动ssh服务之后，ssh连接依然提示 ‘Permission denied’ ,经过搜索原来是配置了 禁止root登录策略。<br>把 ‘&#x2F;etc&#x2F;ssh&#x2F;sshd_config’ 里面的配置 ‘PermitRootLogin no’ 改为YES，重启 ssh服务 即可.</p><img src="/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/003.jpg" class="" title="配置"><p>参考文章 ：<a href="https://cloud.tencent.com/developer/article/1454777">SSH连接报错:Permission denied, please try again.的解决方法</a></p><p>   此时可以登录，但是在输入密码之后需要等待十几秒钟才可以连接上，这个问题就比较棘手了，google 搜索了很久才找到答案。<br>修改配置文件 ‘&#x2F;etc&#x2F;pam.d&#x2F;common-session’ 注释掉 ‘pam_systemd.so’ 这一样就行了  无需重启。</p><img src="/2023/02/08/%E5%9C%A8%E7%BE%A4%E6%99%96%E4%B8%8A%E5%88%9B%E5%BB%BAubuntu-docker%E5%AE%B9%E5%99%A8%E5%B9%B6%E7%94%A8ssh%E8%AE%BF%E9%97%AE/004.jpg" class="" title="pam_systemd"><p>参考文章 ： <a href="https://jrs-s.net/2017/07/01/slow-ssh-logins/">A comprehensive guide to fixing slow SSH logins</a></p><p>至此，ssh 登录ubuntu docker容器终于正常了。</p>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群晖Docker设置bridge-host模式</title>
    <link href="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>  首先群晖默认网络模式是bridge模式和host模式,我们将开启的网络模式是 bridge-host 模式。<br>  <img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/001.jpg" class="" title="群晖网络模式"></p><p>Bridge: docker容器内部虚拟网桥，容器内部 172.17.0.X 网段 无法获取主机网络 ip 访问容器需要映射端口 并且不能和主机占用端口冲突 不映射端口无法使用</p><p>Host：host模式 将容器绑定到主机网卡使用主机的ip 并且不能和主机占用端口冲突 使用哪些端口自动占用</p><p>bridge-host：通过主机的虚拟网卡来创建虚拟网桥 将容器的网卡绑定到这个直通局域网的虚拟网桥上</p><p>优点：容器获取到局域网ip， 容器ip和群晖主机一个网段，端口 1-65535 全端口使用 不和主机冲突 ip手动指定</p><p>可以说 bridge-host 模式就是把容器都桥接到你群晖所在的局域网</p><p>开启bridge-host网络方法：</p><p>一.群晖相关设置</p><ol><li>打开群晖控制面板 ——网络——网络界面——管理——Open vSwitch设置</li></ol>  <img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/002.jpg" class="" title="网络配置">  <img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/003.jpg" class="" title="网络配置"><ol start="2"><li>群晖控制面板——终端机和SNMP——开启SSH功能  <img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/004.jpg" class="" title="网络配置"></li></ol><p>二.执行命令<br>3. 用putty工具SSH登录进群晖并切换到root账户</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo -<span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><ol start="4"><li>执行创建网络命令，根据自己的IP网段修改，我的IP网段为 192.168.50.X，网关地址为 192.168.50.35<br>  这里网关设置为旁路由的网关（因为 docker 运行的时候同在群晖上的 openwrt旁路由 也必然运行。）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker network create -d macvlan <span class="hljs-attr">--subnet</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">50.0</span>/<span class="hljs-number">24</span> <span class="hljs-attr">--gateway</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">50.35</span> -o parent=ovs_eth0 bridge-host<br></code></pre></td></tr></table></figure></li></ol><p>创建容器的时候注意选择 bridge-host 模式</p> <img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/005.jpg" class="" title="bridge-host"><p>注意如果要在docker里面使用 ifconfig 配置网络会提示没权限(即便是用root用户) ，是因为创建容器的时候没有选择  使用高权限执行容器。</p><img src="/2023/02/05/%E7%BE%A4%E6%99%96Docker%E8%AE%BE%E7%BD%AEbridge-host%E6%A8%A1%E5%BC%8F/006.jpg" class="" title="使用高权限执行容器"><p>参考网络文章:</p><p><a href="https://www.zhoujie218.top/archives/1018.html">群晖docker开启局域网桥接，获取独立IP</a><br><a href="https://icn.ink/synology/3.html">群晖Docker设置bridge-host模式</a></p>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梅林路由器自动切换网关</title>
    <link href="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/"/>
    <url>/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>   经过一段时间梅林插件 clash 的使用，感觉到不稳定速度还慢，只能转向软路由，一顿研究后终于选择openwrt。<br>用梅林作主路由，openwrt作为旁路由。网络拓扑结构如下所示：</p><img src="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/001.jpg" class="" title="图片引用方法一"><p>  梅林做主路由特点是稳定，功耗低，有24小时开机的需求和条件，用来提供无线接入和基本的插件 frp,通过 frp 远程控制梅林来启动其他设备。<br>  旁路由是在群晖上的一个虚拟机安装的，x86架构的openwrt 功能十分强大，可以轻松的实现穿墙和去广告 （以后还会启用更多的功能）。<br>主路由旁路由想要配合工作需要各自有对应的设置，旁路由配置如下(局域网上所有设备都经过旁路由)：</p><img src="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/002.jpg" class="" title="网络 -&gt; 接口 -&gt; LAN 基本设置"><img src="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/003.jpg" class="" title="网络 -&gt; 接口 -&gt; LAN 高级设置"><p> 主路由设置需分两种情况，一种是旁路由开启的时候设置如下(局域网上所有设备都经过旁路由):</p> <img src="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/004.jpg" class="" title="内部网络 -&gt; DHCP服务器"><p>还有一种是旁路由关闭的时候，主路由自己也能提供基本的上网功能，配置如下：</p> <img src="/2023/02/04/%E6%A2%85%E6%9E%97%E8%B7%AF%E7%94%B1%E5%99%A8%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E7%BD%91%E5%85%B3/005.jpg" class="" title="内部网络 -&gt; DHCP服务器"><p>  这样就有一个问题，因为旁路由有时候开启有时候关闭，如果手动修改主路由设置会非常麻烦，应该在主路由上放一个脚本自动检测旁路由是否在线，并设置成相应的模式。</p><p>参考文章: <a href="https://zhuanlan.zhihu.com/p/341954106">merlin-梅林路由器自动切换网关</a></p><p>切换网关的脚本 auto_switch_gateway.sh 如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs css">#!/bin/sh<br><br>default_gateway=&#x27;<span class="hljs-number">192.168</span>.<span class="hljs-number">50.1</span>&#x27;<br>auxiliary_gateway=&#x27;<span class="hljs-number">192.168</span>.<span class="hljs-number">50.35</span>&#x27;<br><br>#公共 DNS网关<br>up_gateway=&#x27;<span class="hljs-number">114.114</span>.<span class="hljs-number">114.114</span>&#x27;<br><br>check_ip_available()&#123;<br>    ping -c <span class="hljs-number">3</span> $<span class="hljs-number">1</span> | grep packets | awk &#x27;&#123;print $<span class="hljs-number">4</span>&#125;&#x27;<br>&#125;<br><br># If the gateway of the up close, the network is completely unusable<br><br>res=`check_ip_available $up_gateway`<br>echo $res<br>if <span class="hljs-selector-attr">[ $((res)) -eq 0 ]</span>; then<br>  echo &quot;up_gateway unusable&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>  exit <span class="hljs-number">1</span><br>fi<br><br><br>cur_gateway=`/usr/sbin/nvram get dhcp_gateway_x` # get current gateway<br><br><br>if <span class="hljs-selector-attr">[ <span class="hljs-string">&quot;$cur_gateway&quot;</span> = <span class="hljs-string">&quot;$default_gateway&quot;</span> ]</span>; then<br>   echo &quot;cur is default_gateway&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>   res=`check_ip_available $auxiliary_gateway`<br>   if <span class="hljs-selector-attr">[ $(($res)) -eq 0 ]</span>; then<br>      echo &quot;auxiliary_gateway is not available,do nothing!d-exit&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>      exit <span class="hljs-number">1</span><br>   fi<br>   #如果当前设置的是主路由，并且旁路由开启了则切换到旁路由<br>   echo &quot;auxiliary_gateway is available,switch <span class="hljs-selector-tag">to</span> auxiliary&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>   # <span class="hljs-selector-tag">to</span> switch<br>   /usr/sbin/nvram set dhcp_gateway_x=$auxiliary_gateway<br>   /usr/sbin/nvram set dhcp_dns1_x=$auxiliary_gateway<br>   /usr/sbin/nvram set dhcp_dns2_x=&quot;&quot;<br>   /usr/sbin/nvram commit<br><br>   /sbin/rc rc_service restart_net_and_phy<br>   exit <span class="hljs-number">0</span><br>fi<br><br><br>if <span class="hljs-selector-attr">[ <span class="hljs-string">&quot;$cur_gateway&quot;</span> = <span class="hljs-string">&quot;$auxiliary_gateway&quot;</span> ]</span>; then<br>   echo &quot;cur is auxiliary_gateway&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>   res=`check_ip_available $auxiliary_gateway`<br>   if <span class="hljs-selector-attr">[ $(($res)) -gt 0 ]</span>; then<br>      echo &quot;auxiliary_gateway is available,do nothing! <span class="hljs-selector-tag">a</span>-exit&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>      exit <span class="hljs-number">1</span><br>   fi<br>   #如果当前设置的是旁路由，但是旁路由关闭了，则切换回主路由<br>   echo &quot;auxiliary_gateway is not available,switch <span class="hljs-selector-tag">to</span> default&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br>   # <span class="hljs-selector-tag">to</span> switch<br>   /usr/sbin/nvram set dhcp_gateway_x=$default_gateway<br>   /usr/sbin/nvram set dhcp_dns1_x=<span class="hljs-number">119.29</span>.<span class="hljs-number">29.29</span><br>   /usr/sbin/nvram set dhcp_dns2_x=<span class="hljs-number">223.5</span>.<span class="hljs-number">5.5</span><br>   /usr/sbin/nvram commit<br><br>   /sbin/rc rc_service restart_net_and_phy<br>   exit <span class="hljs-number">0</span><br>fi<br><br>echo &quot;nothing change&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/log/auto_switch_gateway<span class="hljs-selector-class">.log</span><br></code></pre></td></tr></table></figure><p>   &#x2F;sbin&#x2F;rc rc_service restart_net_and_phy，这句命令，其实就是路由器修改本地网关后，会触发的命令。相当于手动执行应用本页面设置。</p><p>  另外原参考文章还用到了 init-start 脚本和 create_crontab_auto_switch_gateway.sh 脚本来实现复杂的定时调用，这里就不用了，<br>直接在主路由启动之后执行如下命令即可(主路由很久才会重启一次):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">echo &quot;* * * * * /bin/sh /jffs/scripts/auto_switch_gateway<span class="hljs-selector-class">.sh</span>&quot; &gt;&gt; /<span class="hljs-selector-tag">var</span>/spool/cron/crontabs/admin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS输出函数调用栈</title>
    <link href="/2022/08/01/JS%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <url>/2022/08/01/JS%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>最近看一个前端小游戏，需要获取当前代码执行时所在的位置（从哪个函数调用过来的，一层层向上回溯），方便代码定位，于是就总结下 JavaScript 如何输出函数调用栈。</p><p>先看一个hello world 程序:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a</span>) &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure><p>上面 main 函数调用了fun 函数， 使用 <code>console.trace() </code> 跟踪函数调用栈 。(经过测试 trace 加不加参数 ‘fun’ 结果都是一样的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">let</span> a = <span class="hljs-title function_">fun</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params">a</span>) &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">trace</span>(<span class="hljs-string">&#x27;fun&#x27;</span>)<br><span class="hljs-keyword">return</span> a<br>&#125;<br><br><span class="hljs-title function_">main</span>()<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">Trace: fun<br>    at fun (/home/mat/work/<span class="hljs-number">1</span>.js:<span class="hljs-number">7</span>:<span class="hljs-number">10</span>)<br>    at main (/home/mat/work/<span class="hljs-number">1</span>.js:<span class="hljs-number">2</span>:<span class="hljs-number">10</span>)<br>    at Object.&lt;anonymous&gt; (/home/mat/work/<span class="hljs-number">1</span>.js:<span class="hljs-number">11</span>:<span class="hljs-number">1</span>)<br>    at Module._compile (internal/modules/cjs/loader.js:<span class="hljs-number">778</span>:<span class="hljs-number">30</span>)<br>    at Object.Module._extensions..js (internal/modules/cjs/loader.js:<span class="hljs-number">789</span>:<span class="hljs-number">10</span>)<br>    at Module.load (internal/modules/cjs/loader.js:<span class="hljs-number">653</span>:<span class="hljs-number">32</span>)<br>    at tryModuleLoad (internal/modules/cjs/loader.js:<span class="hljs-number">593</span>:<span class="hljs-number">12</span>)<br>    at Function.Module._load (internal/modules/cjs/loader.js:<span class="hljs-number">585</span>:<span class="hljs-number">3</span>)<br>    at Function.Module.runMain (internal/modules/cjs/loader.js:<span class="hljs-number">831</span>:<span class="hljs-number">12</span>)<br>    at startup (internal/bootstrap/node.js:<span class="hljs-number">283</span>:<span class="hljs-number">19</span>)<br>hello world<br></code></pre></td></tr></table></figure><p>参考链接：<br><a href="https://juejin.cn/post/7019108610332426248">JS输出函数调用栈</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下使用keysmith实现icp转账</title>
    <link href="/2022/07/24/linux%E4%B8%8B%E4%BD%BF%E7%94%A8keysmith%E5%AE%9E%E7%8E%B0icp%E8%BD%AC%E8%B4%A6/"/>
    <url>/2022/07/24/linux%E4%B8%8B%E4%BD%BF%E7%94%A8keysmith%E5%AE%9E%E7%8E%B0icp%E8%BD%AC%E8%B4%A6/</url>
    
    <content type="html"><![CDATA[<p>  早期的icp各种钱包 通过同样的一组私钥生成的地址是不一样的，比如Stoic Wallet和plug，但是 plug 和 keysmith 工具生成的地址是一样的， 本视频介绍使用keysmith来创建icp地址和转账。</p><iframe src="//www.youtube.com/embed/EHzHwDN9HEs" frameborder="0" allowfullscreen=""></iframe><p>本文提到的链接：<br><a href="https://github.com/dfinity/keysmith">https://github.com/dfinity/keysmith</a></p>]]></content>
    
    
    <categories>
      
      <category>web3开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网件R7000梅林固件使用frp实现群晖唤醒和远程访问</title>
    <link href="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <url>/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>硬件：       刷了梅林380.70_0-X7.9.1版本固件的网件R7000路由器<br>            群晖 DS220+<br>            有公网ip 的主机一台，这里用的腾讯云</p><p>  因为群晖运行的时候有一些噪音，加上在外租房电费比较高，所以不适合24小时开机,最好能设置成用到的时候远程启动，并且远程访问。这就要用到frp了。</p><p>仿照前面的文章在路由器软件中心里面安装上插件 frpc ，注意frpc 稳定运行需要有虚拟内存。再买一个frps服务，我用的是腾讯云，一年50元。</p><p>整个运行流程涉及到四个设备，分别是</p><ol><li>控制端手机，用来控制群晖启动，访问群晖数据，手机直接访问的是 frps ，在这里是这里是<br>2）腾讯云主机 ，云主机运行 frps 服务作为中转和<br>3）路由器上的frpc 客户端实现交互，frpc客户端配置的穿透服务，最终交互就是<br>4）群晖DS220+</li></ol><p>首先登陆腾讯云，我用的是 winserver 系统。 下载和路由器上frpc 版本对应的frps ，这个版本对应很重要。 </p><p>然后就是配置 frps.ini 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[common]</span><br># 设置地址及通信端口<br>bind_addr = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br>bind_port = <span class="hljs-number">7000</span><br><br># 监听<span class="hljs-number">7080</span>与<span class="hljs-number">7443</span>端口，进行 HTTP 与 HTTPS 代理，HTTP 与 HTTPS 端口可以成设置一样<br>vhost_http_port = <span class="hljs-number">7080</span><br>vhost_https_port = <span class="hljs-number">7443</span><br><br># 设置查看仪表板服务地址及端口，dashboard_addr 不设置，默认与 bind_addr 一样，如果不设置 dashboard_port 端口不会开启这个服务<br>dashboard_addr = <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span><br>dashboard_port = <span class="hljs-number">7500</span><br><br># 设置仪表盘服务的登录的账号与密码，如果不设置就默认都是 admin<br>dashboard_user = admin<br>dashboard_pwd = xxxxxx<br> <br># 设置Token, 尽量配置复杂些，配置 frpc 会用到<br>token = xxxxxx<br></code></pre></td></tr></table></figure><p>frps 配置基本上都是一个模式，参考github上的示例修改下就可以了。注意最好这里把目录下frpc相关的所有文件都删除，只保留frps相关的文件，要不然会不小心弄混。</p><p>然后就是路由器上的 frpc 配置 :</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/001.png" class="" title="图片引用方法一"><p>上图中简单设置部分，服务器一栏填写腾讯云的公网ip地址。http穿透服务端口，https穿透服务端口 要和 配置文件 frps.ini 里面的 对应。frpc 用户名称随便填。</p><p>穿透服务配置下面两行代表两个服务，一个是 远程唤醒服务，协议类型是 udp ，内网主机地址就是群晖的局域网ip地址（静态分配IP）。远程主机端口 要和 手机上唤醒软件的配置一致，代理名称是 MyWake ，用来把群晖远程唤醒。</p><p>手机上Magic Packet配置：(注意mac地址就是群晖的mac地址，WOL 地址是云服务器地址)</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/003.jpg" class="" title="手机设置"><p>按照上面设置好了之后，发现一个问题，就是路由器重启之后就无法直接从远程启动群晖了。需要 <span style="color:rgb(200, 0, 0);">在局域网里面启动一次群晖之后，保持路由器不要重启，再次启动群晖的时候才可以远程启动，</span>至于原因还没找到（arp 绑定设备也做了）先这样用着吧，好在R7000稳如老狗，搭配上UPS应该可以做到常年不用重启了。</p><p>还有一个是 远程访问服务，协议类型是 http ，代理名称是 webdav ，域名配置也要填写服务器的ip地址，如果不填写就会在手机链接的时候遇到 <code>[W] [newhttp.go:202] http: proxy error: no such domain</code> 的错误。 参考链接： <a href="https://www.dazhuanlan.com/wowowokao/topics/1697175">frp实现内网穿透</a> 。内网主机端口是群晖 webdav 服务的http端口 ：</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/002.png" class="" title="群晖webdav配置"><p>nPlayer 访问Webdav设置：</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/004.jpg" class="" title="nPlayer访问Webdav设置"><p> 上图中 主机填写云服务公网ip ，用户名和密码就填写 webdav 服务的用户名和密码 ，端口就是远程主机的端口。</p><p>至此就可以在手机上通过 frp + webdav 协议 访问群晖里面的音视频文件了。</p><p>为什么使用webdav 协议：<br>  因为 WEBDAV 有各种音视频播放器的支持，很方便。以前想从外网播放群晖的音乐使用官方播放器界面丑陋不说，连接速度还很慢。按照网友 <a href="https://laosu.ml/archives/page/2/">老苏的blog</a> 博客尝试过 Dim koel 等各种流媒体方案结果搭建十分麻烦，有的还要花钱，播放器还十分的小众。不如用支持 webdav 协议的播放器，用的人多，播放效果也很不错。</p><p>PC主机的远程唤醒和远程控制和这个原理差不多，仿照这个弄就可以了，这里就不写了。</p><hr><p>2023年2月4号更新:<br>  经过一段时间的使用发现， frp 转发 Magic Packet 开机包很不稳定（或许问题在其它环节）。有时候可以唤醒有时候就无法唤醒。<br>无奈只能想另外的方案。<br>  考虑到梅林固件本身其实也有唤醒功能的，而且梅林设备一直在线，可以用 frp 配置 远程登陆梅林固件，然后再操作梅林固件来唤醒同一个局域网段的其他设备。</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/005.png" class="" title="远程控制梅林设置"><p>  通过上面的设置，就可以保证远程登陆梅林固件了，然后再在梅林里面设置 其他设备唤醒的方式</p><img src="/2022/07/24/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8frp%E5%AE%9E%E7%8E%B0%E7%BE%A4%E6%99%96%E5%94%A4%E9%86%92%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/006.jpg" class="" title="梅林唤醒局域网设备"><p>这种唤醒方式和上面的唤醒方式不同的地方在于，这里的唤醒包是梅林发出的，在局域网内部直接给目标设备，这个唤醒过程是很稳定的。<br>上面的方式 唤醒包是通过手持终端发出的，经过 vps 到达梅林，再由梅林转发给目标设备，这个过程很不稳定，经常唤醒失败！</p>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网件R7000梅林固件使用遇到的几个小问题</title>
    <link href="/2022/07/23/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/07/23/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>    目前手头有一个 Netgear R7000 ,刷了梅林固件380.70_0-X7.9.1 。</p><p>    按照 <a href="https://www.youtube.com/watch?v=LwYMQEyUz60">油管网友的教程</a>使用离线安装的方式 刷了 clash 固件用来科学上网很好用。在这过程中也遇到了各种问题。最常见的比如说 安装的时候提示 有敏感词的，需要开启ssh 登录路由器后台输入shell 命令解除。</p><p>   我想再用在线安装的方式安装一些其他的插件，比如说frpc 实现内网穿透，但是发现软件中心无法更新， 一直显示版本0.0，经过搜索发现是 380版本固件用的是 <a href="https://ngrok.wang/">https://ngrok.wang</a> 这个域名，但是这个域名过期了。</p><p>还需要 ssh 登录后台shell 命令修改域名 ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">sed -<span class="hljs-selector-tag">i</span> &#x27;s/koolshare<span class="hljs-selector-class">.ngrok</span><span class="hljs-selector-class">.wang</span>/ks<span class="hljs-selector-class">.ddnsto</span><span class="hljs-selector-class">.com</span>/g&#x27; /koolshare/scripts/ks_app_install<span class="hljs-selector-class">.sh</span><br>sed -<span class="hljs-selector-tag">i</span> &#x27;s/koolshare<span class="hljs-selector-class">.ngrok</span><span class="hljs-selector-class">.wang</span>/ks<span class="hljs-selector-class">.ddnsto</span><span class="hljs-selector-class">.com</span>/g&#x27; /koolshare/webs/Main_Soft_center<span class="hljs-selector-class">.asp</span><br></code></pre></td></tr></table></figure><p> <span style="color:rgb(200, 0, 0);"> 注意修改之后要用vi打开文件搜索确认一下是否都完成了替换 </span></p><p>参考链接： <a href="https://www.dreambuildinglab.com/router/merlin/koolshare-software-center-cannot-be-updated-solution.html">Koolshare软件中心无法更新解决方案</a></p><p>改好之后可以加载软件中心了，但是各种插件版本比较老了，比如说 frpc还是古老的 0.20.0 版本，想着先安装试试能不能与frps 建立起连接。</p><p>​ 结果遇到了下载文件校验不一致的问题，按照 <a href="https://www.right.com.cn/forum/thread-8091282-1-1.html">Softcenter下载文件校验不一致</a>  的方法需要删除&#x2F;jffs 目录下的<br>.koolshare 文件夹，在删除之前最好把这个目录备份起来。 然后再执行命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">kill -<span class="hljs-number">9</span> $(pidof skipd)<br>cd /jffs &amp;&amp; rm -r .<span class="hljs-selector-attr">[a-zA-Z_]</span>* *<br>reboot<br></code></pre></td></tr></table></figure><p>重启…. 结果等了很久也无法联网，打开cmd查看， 发现竟然无法正确的获取ip地址，也就是路由器DHCP都没启动，害怕是路由器坏了。赶紧 手动给电脑分配一个ip  (192.168.50.xx),分配ip之后尝试ping 路由器可以ping 的通。 用 ssh 登录路由器 把上一步删除的 .koolshare 文件夹恢复一下<br>再重启，路由器居然又正常了。</p><p>打开软件中心再次尝试安装 frpc插件也没有 “下载文件校验不一致！” 的错误了。 </p><p>安装虚拟内存插件也遇到了这个问题，用同样的方式解决就可以了。</p><img src="/2022/07/23/%E7%BD%91%E4%BB%B6R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/001.png" class="" title="图片引用方法一"><p>后记：<br>   下载离线安装插件的时候不光要知道梅林固件版本，还要知道  网件R7000 处理器架构版本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"># cat /proc/cpuinfo<br>Processor       : ARMv7 Processor rev <span class="hljs-number">0</span> (v7l)<br>processor       : <span class="hljs-number">0</span><br>BogoMIPS        : <span class="hljs-number">1998.84</span><br><br>processor       : <span class="hljs-number">1</span><br>BogoMIPS        : <span class="hljs-number">1998.84</span><br><br>Features        : swp half thumb fastmult edsp<br>CPU implementer : <span class="hljs-number">0</span>x41<br>CPU architecture: <span class="hljs-number">7</span><br>CPU variant     : <span class="hljs-number">0</span>x3<br>CPU part        : <span class="hljs-number">0</span>xc09<br>CPU revision    : <span class="hljs-number">0</span><br><br>Hardware        : Northstar Prototype<br>Revision        : <span class="hljs-number">0000</span><br>Serial          : <span class="hljs-number">0000000000000000</span><br></code></pre></td></tr></table></figure><p>可以看出是 armv7l 架构 32位版本。</p><p>感觉clash比起 shadowsocks 要好用多了。 直接在路由器上科学上网 就不用再单独的设置每一个设备了，有些设备比如说机顶盒游戏主机设置代理很麻烦。使用路由器也可以减少登录设备数量，有的机场也会限制这个数量。</p><p>在使用苹果随行功能的时候如果局域网某个设备打开了代理，那么导致随行失败。而路由器作为全局的网络出口把代理设在这里就没有这种问题。</p>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>R7000梅林固件设置虚拟内存</title>
    <link href="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>硬件准备 :   刷了梅林380.70_0-X7.9.1固件的 网件R7000路由器一台<br>            一个 8G 的U盘 </p><p>首先使用 DiskGenius 把U盘格式化为ext4 格式。</p><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/001.png" class="" title="图片引用方法一"><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/002.png" class="" title="图片引用方法一"><p>格式化好U盘之后，把U盘插到路由器上 <span style="color:rgb(200, 0, 0);">[ 建议插到USB2.0口上,我曾经把U盘插到USB3.0口上结果虚拟内存运行一会clash插件失灵了，我只测试了一次，为了保险起见还是插到2.0口上吧 ] </span><br>，然后到软件中心安装虚拟内存插件</p><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/004.png" class="" title="图片引用方法一"><p>进入虚拟内存插件后可以看到状态，选择虚拟内存大小，建议512M或1G :</p><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/005.png" class="" title="图片引用方法一"><p>最后创建虚拟内存等待完成即可 </p><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/005-1.png" class="" title="图片引用方法一"><p><span style="color:rgb(200, 0, 0);">注意，如果你在刚创建完虚拟内存之后就查看虚拟内存大小，不管是在命令行 还是在路由器界面看到的虚拟内大小都是0 ，需要等待几分钟， 在命令行时刻观察虚拟内存大小，等这个数值涨到指定的大小之后虚拟内存才可以使用。</span></p><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/006-1.png" class="" title="图片引用方法一"><img src="/2022/07/17/R7000%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/006.png" class="" title="图片引用方法一">]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10和Mac双系统装机整理完美启动</title>
    <link href="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/"/>
    <url>/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<p>系统配置和布局：<br>主板：微型B460m mortar 非wifi版本<br>Cpu：I5 – 10400 （带核显）<br>内存:金士顿Fury骇客神条2666（共48G） 16G + 8G + 16G + 8G<br>显卡：瀚凯 RX6600xt<br>硬盘：西数SN550 500G  金士顿M.2接口（NVME协议）1T.<br>网卡：BCM94360CS2  </p><img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/001.png" class="" title="图片引用方法一"><p> 西数SN550 插在第一个（靠近cpu的）M2口，网卡通过转接板插在第二个M2口，金士顿M.2固态通过pcie转m2插在最下面的pcie接口上。Rx6600xt装在最上面pcie口。 剩下sata1口和sata2口还有两个盘。</p><p>首先安装黑苹果，安装过程参考OpenCore官方的教程<a href="https://dortania.github.io/OpenCore-Install-Guide/prerequisites.html#prerequisites">https://dortania.github.io/OpenCore-Install-Guide/prerequisites.html#prerequisites</a> .这里说明一下，这里的安装也分在线和离线安装，我选择的是在线安装，也就是制作一个启动U盘，在安装的过程中自动下载指定的mac系统。</p><p>还有不同的制作安装U盘的方案，我用的是在win10下用rufus的方案，主要参考的过程：Making the installer in Windows | OpenCore Install Guide (dortania.github.io) ，感觉这种方式是最安全的，因为全程所用到的工具只有python3 和rufus。.这个教程制作完之后得到 com.apple.recovery.boot 文件夹，剩下的EFI文件夹是用大佬制作的现成的： <a href="https://github.com/fpfeng/Hackintosh-10400-B460M-MORTAR">GitHub - fpfeng&#x2F;Hackintosh-10400-B460M-MORTAR </a><br>最终得到U盘根目录如下所示：</p><img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/002.png" class="" title="图片引用方法一"><p>插上U盘 进bios选择U盘启动，剩下就是按照提示一步步安装这中间没遇到什么问题，把mac装到SN550盘里面。</p><p>装好mac系统之后再把sata盘的win10用 DiskGenius迁移到金士顿M.2 1T固态里面。试了迁移两次都无法启动无奈只能重新安装一遍了。但是安装完之后出问题了：在<text color="red">UEFI硬盘BBS优先权</text>  选项里面看不到win10的盘（也就是金士顿M2固态）（下图是正常时候拍的）</p><img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/003.png" class="" title="图片引用方法一"><p>以前win10安装在sata盘里面的时候在这里还能识别到win10 的bootManager呢。现在装到pcie转接口的M2盘就看不到了，切换到存储设备列表界面可以看到stat1~2口的盘和M2_1接口盘。M2的第一个口是西数，M2的第二个口插着bcm网卡，除此之外就看不到别的了：</p><img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/004.png" class="" title="图片引用方法一"><p> 还以为是bios没法识别pcie口转接的盘导致的，无奈只能把pcie接口的金士顿盘和网卡换个位置结果在存储设备列表界面能看到金士顿盘了，但是在UEFI硬盘BBS优先权里面还是无法找到这个盘里的系统。后来才知道是因为硬盘没有ESP分区（里面有EFI文件）bios就搜索不到。</p> <img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/005.png" class="" title="图片引用方法一"><p> 为什么没有这个分区？ 以前安装都是有的，而且在虚拟机里面安装的win10都有这个分区，经过搜索得知 <text color="red">测到有一个硬盘有EFI分区了那么安装的系统就不再有这个分区</text> 。前面已经说了安装了黑果已经有一个EFI分区了，知道原因后就把苹果系统所在的SN550拆下来，再次重新安装win10，这次安装的终于有了ESP分区了，在苹果的OC界面和bios的硬盘启动顺序都能识别到win10的引导项了。</p>  <img src="/2022/07/11/win10%E5%92%8CMac%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA%E6%95%B4%E7%90%86%E5%AE%8C%E7%BE%8E%E5%90%AF%E5%8A%A8/006.png" class="" title="图片引用方法一"><p> 但是还遇到了另外重要的问题，就是用OC来引导win10会遇到ACPI error的蓝屏错误，这个问题经过大量的查阅资料终于发现是config.plist文件的一个配置 SSDT-GPRW.aml 这里从false 改为 true即可解决。</p><p>还有rx6600xt在黑果启动阶段黑屏的问题，可以加上引导启动参数agdpmod&#x3D;pikera 解决！</p>]]></content>
    
    
    <categories>
      
      <category>系统管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/09/hello-world/"/>
    <url>/2022/07/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
